
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Advanced Topic with Python Channel Access &#8212; Epics Channel Access for Python</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/epicsdoc.css?v=29cb9c05" />
    <script src="_static/documentation_options.js?v=0abfba44"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="wx: wxPython Widgets for Epics" href="wx.html" /> 
  </head><body>
<div style="background-color: #E7F0F3; text-align: left; padding: 8px 4px 8px 4px">
  <font size=+3><a href="index.html">
      <img src="_static/pyepics.png" height=50 border="0" alt="pyepics"/>
    &nbsp; PyEpics: Epics Channel Access for Python</a>
  </font>
</div>

    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wx.html" title="wx: wxPython Widgets for Epics"
             accesskey="P">previous</a> |</li>
   <li>[<a href="installation.html">install</a></li>
   <li>|<a href="overview.html">overview</a></li>
   <li>|<a href="pv.html">pv</a></li>
   <li>|<a href="ca.html">ca</a></li>
   <li>|<a href="arrays.html">arrays</a></li>
   <li>|<a href="devices.html">devices</a></li>
   <li>|<a href="alarm.html">alarm</a></li>
   <li>|<a href="autosave.html">autosave</a></li>
   <li>|<a href="wx.html">wx</a></li>
   <li>|<a href="#">advanced</a>]</li>

        <li class="nav-item nav-item-this"><a href="">Advanced Topic with Python Channel Access</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Advanced Topic with Python Channel Access</a><ul>
<li><a class="reference internal" href="#the-wait-and-timeout-options-for-get-ca-get-complete">The wait and timeout options for get(), ca.get_complete()</a></li>
<li><a class="reference internal" href="#strategies-for-connecting-to-a-large-number-of-pvs">Strategies for connecting to a large number of PVs</a></li>
<li><a class="reference internal" href="#time-sleep-or-epics-poll">time.sleep() or epics.poll()?</a></li>
<li><a class="reference internal" href="#using-python-threads">Using Python Threads</a><ul>
<li><a class="reference internal" href="#channel-access-contexts">Channel Access Contexts</a></li>
<li><a class="reference internal" href="#how-to-work-with-ca-and-threads">How to work with CA and Threads</a></li>
<li><a class="reference internal" href="#thread-examples">Thread Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-multiprocessing-with-pyepics">Using Multiprocessing with PyEpics</a><ul>
<li><a class="reference internal" href="#CAProcess"><code class="docutils literal notranslate"><span class="pre">CAProcess</span></code></a></li>
<li><a class="reference internal" href="#CAPool"><code class="docutils literal notranslate"><span class="pre">CAPool</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="wx.html"
                          title="previous chapter">wx: wxPython Widgets for Epics</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/advanced.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="advanced-topic-with-python-channel-access">
<h1>Advanced Topic with Python Channel Access<a class="headerlink" href="#advanced-topic-with-python-channel-access" title="Link to this heading">¶</a></h1>
<p>This chapter contains a variety of “usage notes” and implementation
details that may help in getting the best performance from the
pyepics module.</p>
<section id="the-wait-and-timeout-options-for-get-ca-get-complete">
<span id="advanced-get-timeouts-label"></span><h2>The wait and timeout options for get(), ca.get_complete()<a class="headerlink" href="#the-wait-and-timeout-options-for-get-ca-get-complete" title="Link to this heading">¶</a></h2>
<p>The <em>get</em> functions, <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget()</span></code></a>, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> and <a class="reference internal" href="ca.html#epics.ca.get" title="epics.ca.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get()</span></code></a>
all ask for data to be transferred over the network.  For large data arrays
or slow networks, this can can take a noticeable amount of time.  For PVs
that have been disconnected, the <em>get</em> call will fail to return a value at
all.  For this reason, these functions all take a <cite>timeout</cite> keyword option.
The lowest level <a class="reference internal" href="ca.html#epics.ca.get" title="epics.ca.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get()</span></code></a> also has a <cite>wait</cite> option, and a companion
function <a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a>.  This section describes the details of
these.</p>
<p>If you’re using <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget()</span></code></a> or <a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> you can supply a
timeout value.  If the value returned is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then either the PV has
truly disconnected or the timeout passed before receiving the value.  If
the <em>get</em> is incomplete, in that the PV is connected but the data has
simply not been received yet, a subsequent <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget()</span></code></a> or
<a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> will eventually complete and receive the value.  That is, if
a PV for a large waveform record reports that it is connected, but a
<a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> returns None, simply trying again later will probably work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="s1">&#39;LargeWaveform&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>At the lowest level (which <a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> and <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget()</span></code></a> use),
<a class="reference internal" href="ca.html#epics.ca.get" title="epics.ca.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get()</span></code></a> issues a get-request with an internal callback function.
That is, it calls the CA library function
<code class="xref py py-func docutils literal notranslate"><span class="pre">libca.ca_array_get_callback()</span></code> with a pre-defined callback function.
With <cite>wait=True</cite> (the default), <a class="reference internal" href="ca.html#epics.ca.get" title="epics.ca.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get()</span></code></a> then waits up to the timeout
or until the CA library calls the specified callback function.  If the
callback has been called, the value can then be converted and returned.</p>
<p>If the callback is not called in time or if <cite>wait=False</cite> is used but the PV
is connected, the callback will be called eventually, and simply waiting
(or using <a class="reference internal" href="ca.html#epics.ca.pend_event" title="epics.ca.pend_event"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.pend_event()</span></code></a> if <a class="reference internal" href="ca.html#epics.ca.PREEMPTIVE_CALLBACK" title="epics.ca.PREEMPTIVE_CALLBACK"><code class="xref py py-data docutils literal notranslate"><span class="pre">epics.ca.PREEMPTIVE_CALLBACK</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">False</span></code>) may be sufficient for the data to arrive.  Under this condition,
you can call <a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a>, which will NOT issue a new request
for data to be sent, but wait (for up to a timeout time) for the previous
get request to complete.</p>
<p><a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">None</span></code> if the timeout is exceeded or
if there is not an “incomplete get” that it can wait to complete.  Thus,
you should use the return value from <a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a> with care.</p>
<p>Note that <a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> (and so <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget()</span></code></a>) will normally rely on
the PV value to be filled in automatically by monitor callbacks.  If
monitor callbacks are disabled (as is done for large arrays and can be
turned off) or if the monitor hasn’t been called yet, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get()</span></code></a> will
check whether it should can <a class="reference internal" href="ca.html#epics.ca.get" title="epics.ca.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get()</span></code></a> or <a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a>.</p>
<p>If not specified, the timeout for <a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a> (and all other
get functions) will be set to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">log10</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, that’s the maximum time that will be waited, and if the data is
received faster than that, the <em>get</em> will return as soon as it can.</p>
</section>
<section id="strategies-for-connecting-to-a-large-number-of-pvs">
<span id="advanced-connecting-many-label"></span><h2>Strategies for connecting to a large number of PVs<a class="headerlink" href="#strategies-for-connecting-to-a-large-number-of-pvs" title="Link to this heading">¶</a></h2>
<p>Occasionally, you may find that you need to quickly connect to a large
number of PVs, say to write values to disk.  The most straightforward way
to do this might be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">epics</span>

<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>
<span class="n">pv_vals</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">:</span>
    <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">pv_vals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>or even just:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">epics</span><span class="o">.</span><span class="n">caget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">]</span>
</pre></div>
</div>
<p>Though convenient, this does incur some performance penalty that you may
sometimes wish to avoid. To minimize the penalty, we need to understand its
cause.</p>
<p>Creating a <cite>PV</cite> object (using any of <a class="reference internal" href="pv.html#pv.PV" title="pv.PV"><code class="xref py py-class docutils literal notranslate"><span class="pre">pv.PV</span></code></a>, or <a class="reference internal" href="pv.html#pv.get_pv" title="pv.get_pv"><code class="xref py py-func docutils literal notranslate"><span class="pre">pv.get_pv()</span></code></a>, or
<a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget()</span></code></a>) will automatically use connection and event callbacks in
an attempt to keep the <cite>PV</cite> alive and up-to-date during the seesion.  This is
usually an advantage, as you don’t need to explicitly deal with many aspects of
Channel Access.  But creating a <cite>PV</cite> does request some network traffic, and the
<cite>PV</cite> will not be “fully connected” and ready to do a <code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.get()</span></code> until all
the connection and event callbacks are established.  In fact, <code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.get()</span></code>
will not run until those connections are all established.  For any individual
PV, this takes very close to 30 milliseconds for each PV.  That is, for 1000
PVs, the above approach will take about 30 seconds.</p>
<p>But that time to wait for PV connections does not need to be done one at a time
and in series.  The simplest way to speed up the above task would allow all
those connections to happen in parallel and in the background by first creating
all the PVs and then getting their values.  That would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># improve time to get multiple PVs:  Method 1</span>
<span class="kn">import</span> <span class="nn">epics</span>

<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>
<span class="n">pvs</span> <span class="o">=</span> <span class="p">[</span><span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
</pre></div>
</div>
<p>Though it doesn’t look that different, this improves performance by a
factor of 100, so that getting 1000 PV values will take around 0.4 seconds.</p>
<p>Can it be improved further?  The answer is Yes, but at a price.  For the
discussion here, we’ll call the original version “Method 0” and the method of
creating all the PVs then getting their values “Method 1”.  With both of these
approaches, the script has fully connected PV objects for all PVs named, so
that subsequent use of these PVs will be very efficient.</p>
<p>But this can be made even faster by turning off any connection or event
callbacks, avoiding <cite>PV</cite> objects altogether, and using the <cite>epics.ca</cite>
interface.  This has been encapsulated into <a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a> which
can be used as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># get multiple PVs as fast as possible:  Method 2</span>
<span class="kn">import</span> <span class="nn">epics</span>
<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">caget_many</span><span class="p">(</span><span class="n">pvlist</span><span class="p">)</span>
</pre></div>
</div>
<p>In tests using 1000 PVs that were all really connected, Method 2 will take
about 0.25 seconds, compared to 0.4 seconds for Method 1 and 30 seconds for
Method 0.  To understand what <a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a> is doing, a more
complete version of this looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># epics.caget_many made explicit:  Method 3</span>
<span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>

<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>

<span class="n">pvdata</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">pvchids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># create, don&#39;t connect or create callbacks</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">:</span>
    <span class="n">chid</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">auto_cb</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># note 1</span>
    <span class="n">pvchids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chid</span><span class="p">)</span>

<span class="c1"># connect</span>
<span class="k">for</span> <span class="n">chid</span> <span class="ow">in</span> <span class="n">pvchids</span><span class="p">:</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">connect_channel</span><span class="p">(</span><span class="n">chid</span><span class="p">)</span>

<span class="c1"># request get, but do not wait for result</span>
<span class="n">ca</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
<span class="k">for</span> <span class="n">chid</span> <span class="ow">in</span> <span class="n">pvchids</span><span class="p">:</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chid</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># note 2</span>

<span class="c1"># now wait for get() to complete</span>
<span class="n">ca</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
<span class="k">for</span> <span class="n">chid</span> <span class="ow">in</span> <span class="n">pvchids</span><span class="p">:</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_complete</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pvdata</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">chid</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
</pre></div>
</div>
<p>The code here probably needs detailed explanation.  As mentioned above, it
uses the <cite>ca</cite> level, not <cite>PV</cite> objects.  Second, the call to
<a class="reference internal" href="ca.html#epics.ca.create_channel" title="epics.ca.create_channel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.create_channel()</span></code></a> (Note 1) uses <cite>connect=False</cite> and <cite>auto_cb=False</cite>
which mean to not wait for a connection before returning, and to not
automatically assign a connection callback.  Normally, these are not what
you want, as you want a connected channel and to be informed if the
connection state changes, but we’re aiming for maximum speed here.  We then
use <a class="reference internal" href="ca.html#epics.ca.connect_channel" title="epics.ca.connect_channel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.connect_channel()</span></code></a> to connect all the channels.  Next (Note 2),
we tell the CA library to request the data for the channel without waiting
around to receive it.  The main point of not having <a class="reference internal" href="ca.html#epics.ca.get" title="epics.ca.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.get()</span></code></a> wait for
the data for each channel as we go is that each data transfer takes time.
Instead we request data to be sent in a separate thread for all channels
without waiting.  Then we do wait by calling <a class="reference internal" href="ca.html#epics.ca.poll" title="epics.ca.poll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.poll()</span></code></a> once and only
once, (not <cite>len(pvnamelist)</cite> times!).  Finally, we use the
<a class="reference internal" href="ca.html#epics.ca.get_complete" title="epics.ca.get_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.get_complete()</span></code></a> method to convert the data that has now been
received by the companion thread to a python value.</p>
<p>Method 2 and 3 have essentially the same runtime, which is somewhat faster
than Method 1, and much faster than Method 0. Which method you should use
depends on use case.  In fact, the test shown here only gets the PV values
once.  If you’re writing a script to get 1000 PVs, write them to disk, and
exit, then Method 2 (<a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a>) may be exactly what you
want.  But if your script will get 1000 PVs and stay alive doing other
work, or even if it runs a loop to get 1000 PVs and write them to disk once
a minute, then Method 1 will actually be faster.  That is doing
<a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a> in a loop, as with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># caget_many() 10 times</span>
<span class="kn">import</span> <span class="nn">epics</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">caget_many</span><span class="p">(</span><span class="n">pvlist</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>will take around considerably <em>longer</em> than creating the PVs once and
getting their values in a loop with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># pv.get() 10 times</span>
<span class="kn">import</span> <span class="nn">epics</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>
<span class="n">pvs</span> <span class="o">=</span> <span class="p">[</span><span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>In tests with 1000 PVs, looping with <a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a> took about
1.5 seconds, while the version looping over <code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.get()</span></code> took about 0.5
seconds.</p>
<p>To be clear, it is <strong>connecting</strong> to Epics PVs that is expensive, not the
retreiving of data from connected PVs.  You can lower the connection
expense by not retaining the connection or creating monitors on the PVs,
but if you are going to re-use the PVs, that savings will be lost quickly.
In short, use Method 1 over <a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a> unless you’ve benchmarked
your use-case and have demonstrated that <a class="reference internal" href="overview.html#epics.caget_many" title="epics.caget_many"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.caget_many()</span></code></a> is better for
your needs.</p>
</section>
<section id="time-sleep-or-epics-poll">
<span id="advanced-sleep-label"></span><h2>time.sleep() or epics.poll()?<a class="headerlink" href="#time-sleep-or-epics-poll" title="Link to this heading">¶</a></h2>
<p>In order for a program to communicate with Epics devices, it needs to allow
some time for this communication to happen.   With
<a class="reference internal" href="ca.html#epics.ca.PREEMPTIVE_CALLBACK" title="epics.ca.PREEMPTIVE_CALLBACK"><code class="xref py py-data docutils literal notranslate"><span class="pre">epics.ca.PREEMPTIVE_CALLBACK</span></code></a> set to  <code class="docutils literal notranslate"><span class="pre">True</span></code>, this communication  will
be handled in a thread separate from the main Python thread.  This means
that CA events can happen at any time, and <a class="reference internal" href="ca.html#epics.ca.pend_event" title="epics.ca.pend_event"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.pend_event()</span></code></a> does not
need to be called to explicitly allow for event processing.</p>
<p>Still, some time must be released from the main Python thread on occasion
in order for events to be processed.  The simplest way to do this is with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">time.sleep()</span></code>, so that an event loop can simply be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p>Unfortunately, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">time.sleep()</span></code> method is not a very high-resolution
clock, with typical resolutions of 1 to 10 ms, depending on the system.
Thus, even though events will be asynchronously generated and epics with
pre-emptive callbacks does not <em>require</em> <a class="reference internal" href="ca.html#epics.ca.pend_event" title="epics.ca.pend_event"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.pend_event()</span></code></a> or
<a class="reference internal" href="ca.html#epics.ca.poll" title="epics.ca.poll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.poll()</span></code></a> to be run, better performance may be achieved with an event
loop of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">epics</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">evt</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">iot</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>as the loop will be run more often than using <code class="xref py py-meth docutils literal notranslate"><span class="pre">time.sleep()</span></code>.</p>
</section>
<section id="using-python-threads">
<span id="advanced-threads-label"></span><span id="index-0"></span><h2>Using Python Threads<a class="headerlink" href="#using-python-threads" title="Link to this heading">¶</a></h2>
<p>An important feature of the PyEpics package is that it can be used with
Python threads, as Epics 3.14 supports threads for client code.  Even in
the best of cases, working with threads can be somewhat tricky and lead to
unexpected behavior, and the Channel Access library adds a small level of
complication for using CA with Python threads.  The result is that some
precautions may be in order when using PyEpics and threads.  This section
discusses the strategies for using threads with PyEpics.</p>
<p>First, to use threads with Channel Access, you must have
<a class="reference internal" href="ca.html#epics.ca.PREEMPTIVE_CALLBACK" title="epics.ca.PREEMPTIVE_CALLBACK"><code class="xref py py-data docutils literal notranslate"><span class="pre">epics.ca.PREEMPTIVE_CALLBACK</span></code></a> = <code class="docutils literal notranslate"><span class="pre">True</span></code>.  This is the default
value, but if <a class="reference internal" href="ca.html#epics.ca.PREEMPTIVE_CALLBACK" title="epics.ca.PREEMPTIVE_CALLBACK"><code class="xref py py-data docutils literal notranslate"><span class="pre">epics.ca.PREEMPTIVE_CALLBACK</span></code></a> has been set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, threading will not work.</p>
<p>Second, if you are using <code class="xref py py-class docutils literal notranslate"><span class="pre">PV</span></code> objects and not making heavy use of
the <a class="reference internal" href="ca.html#module-epics.ca" title="epics.ca: low-level Channel Access  module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">epics.ca</span></code></a> module (that is, not making and passing around chids), then
the complications below are mostly hidden from you.   If you’re writing
threaded code, it’s probably a good idea to read this just to understand
what the issues are.</p>
<section id="channel-access-contexts">
<h3>Channel Access Contexts<a class="headerlink" href="#channel-access-contexts" title="Link to this heading">¶</a></h3>
<p>The Channel Access library uses a concept of <em>contexts</em> for its own thread
model, with contexts holding sets of threads as well as Channels and
Process Variables.  For non-threaded work, a process will use a single
context that is initialized prior doing any real CA work (done in
<a class="reference internal" href="ca.html#epics.ca.initialize_libca" title="epics.ca.initialize_libca"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.initialize_libca()</span></code></a>).  In a threaded application, each new thread
begins with a new, uninitialized context that must be initialized or
replaced.  Thus each new python thread that will interact with CA must
either explicitly create its own context with <a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.create_context()</span></code></a>
(and then, being a good citizen, destroy this context as the thread ends
with <a class="reference internal" href="ca.html#epics.ca.destroy_context" title="epics.ca.destroy_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.destroy_context()</span></code></a>) or attach to an existing context.</p>
<p>The generally recommended approach is to use a single CA context throughout
an entire process and have each thread attach to the first context created
(probably from the main thread).  This avoids many potential pitfalls (and
crashes), and can be done fairly simply.  It is the default mode when using
PV objects.</p>
<p>The most explicit use of contexts is to put <a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.create_context()</span></code></a>
at the start of each function call as a thread target, and
<a class="reference internal" href="ca.html#epics.ca.destroy_context" title="epics.ca.destroy_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.destroy_context()</span></code></a> at the end of each thread.  This will
cause all the activity in that thread to be done in its own context.  This
works, but means more care is needed, and so is not the recommended.</p>
<p>The best way to attach to the initially created context is to call
<a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.use_initial_context()</span></code></a> before any other CA calls in each
function that will be called by <code class="xref py py-meth docutils literal notranslate"><span class="pre">Thread.run()</span></code>.  Equivalently, you can
add a <code class="xref py py-func docutils literal notranslate"><span class="pre">withInitialContext()</span></code> decorator to the function.  Creating a PV
object will implicitly do this for you, as long as it is your first CA
action in the function.  Each time you do a <code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.get()</span></code> or
<code class="xref py py-meth docutils literal notranslate"><span class="pre">PV.put()</span></code> (or a few other methods), it will also check that the initial
context is being used.</p>
<p>Of course, this approach requires CA to be initialized already.  Doing that
<em>in the main thread</em> is highly recommended.  If it happens in a child
thread, that thread must exist for all CA work, so either the life of the
process or with great care for processes that do only some CA calls.  If
you are writing a threaded application in which the first real CA calls are
inside a child thread, it is recommended that you initialize CA in the main
thread,</p>
<p>As a convenience, the <code class="xref py py-class docutils literal notranslate"><span class="pre">CAThread</span></code> in the <a class="reference internal" href="ca.html#module-epics.ca" title="epics.ca: low-level Channel Access  module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">epics.ca</span></code></a> module is
is a very thin wrapper around the standard <code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code> which
adding a call of  <a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">epics.ca.use_initial_context()</span></code></a> just before your
threaded function is run.  This allows your target functions to not
explicitly set the context, but still ensures that the initial context is
used in all functions.</p>
</section>
<section id="how-to-work-with-ca-and-threads">
<h3>How to work with CA and Threads<a class="headerlink" href="#how-to-work-with-ca-and-threads" title="Link to this heading">¶</a></h3>
<p>Summarizing the discussion above, to use threads you must use run in
PREEMPTIVE_CALLBACK mode.  Furthermore, it is recommended that you use a
single context, and that you initialize CA in the main program thread so
that your single CA context belongs to the main thread.  Using PV objects
exclusively makes this easy, but it can also be accomplished relatively
easily using the lower-level ca interface.  The options for using threads
(in approximate order of reliability) are then:</p>
<blockquote>
<div><p>1. use PV objects for threading work.  This ensures you’re working in a
single CA context.</p>
<p>2. use <code class="xref py py-class docutils literal notranslate"><span class="pre">CAThread</span></code> instead of <code class="xref py py-class docutils literal notranslate"><span class="pre">Thread</span></code> for threads that
will use CA calls.</p>
<p>3. put <a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.use_initial_context()</span></code></a> at the top of all
functions that might be a Thread target function, or decorate them with
<code class="xref py py-func docutils literal notranslate"><span class="pre">withInitialContext()</span></code> decorator, <em>&#64;withInitialContext</em>.</p>
<p>4. use <a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.create_context()</span></code></a> at the top of all functions
that are inside a new thread, and be sure to put
<a class="reference internal" href="ca.html#epics.ca.destroy_context" title="epics.ca.destroy_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.destroy_context()</span></code></a> at the end of the function.</p>
<p>5. ignore this advise and hope for the best.  If you’re not creating
new PVs and only reading values of PVs created in the main thread
inside a child thread, you may not see a problems, at least not until
you try to do something fancier.</p>
</div></blockquote>
</section>
<section id="thread-examples">
<h3>Thread Examples<a class="headerlink" href="#thread-examples" title="Link to this heading">¶</a></h3>
<p>This is a simplified version of test code using Python threads.  It is
based on code originally from Friedrich Schotte, NIH, and included as
<cite>thread_test.py</cite> in the <cite>tests</cite> directory of the source distribution.</p>
<p>In this example, we define a <cite>run_test</cite> procedure which will create PVs
from a supplied list, and monitor these PVs, printing out the values when
they change.  Two threads are created and run concurrently, with
overlapping PV lists, though one thread is run for a shorter time than the
other.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">epics</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">pvnames</span>


<span class="k">def</span> <span class="nf">test_basic_thread</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">thread</span><span class="p">():</span>
        <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">use_initial_context</span><span class="p">()</span>
        <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">use_initial_context</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">test_basic_cathread</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">thread</span><span class="p">():</span>
        <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">use_initial_context</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">CAThread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">test_attach_context</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">thread</span><span class="p">():</span>
        <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">create_context</span><span class="p">()</span>
        <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">pv</span><span class="o">.</span><span class="n">wait_for_connection</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
        <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">detach_context</span><span class="p">()</span>

        <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">attach_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">pv</span><span class="o">.</span><span class="n">wait_for_connection</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">use_initial_context</span><span class="p">()</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">current_context</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_pv_from_main</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">thread</span><span class="p">():</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">use_initial_context</span><span class="p">()</span>
    <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv2</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">CAThread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">thread</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</pre></div>
</div>
<p>In light of the long discussion above, a few remarks are in order: This
code uses the standard Thread library and explicitly calls
<a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.use_initial_context()</span></code></a> prior to any CA calls in the target
function.  Also note that the <code class="xref py py-func docutils literal notranslate"><span class="pre">run_test()</span></code> function is first called
from the main thread, so that the initial CA context does belong to the
main thread.  Finally, the <a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.use_initial_context()</span></code></a> call in
<code class="xref py py-func docutils literal notranslate"><span class="pre">run_test()</span></code> above could be replaced with
<a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">epics.ca.create_context()</span></code></a>, and run OK.</p>
<p>The output from this will look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">First</span><span class="p">,</span> <span class="n">create</span> <span class="n">a</span> <span class="n">PV</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">main</span> <span class="n">thread</span><span class="p">:</span>
<span class="n">Run</span> <span class="mi">2</span> <span class="n">Background</span> <span class="n">Threads</span> <span class="n">simultaneously</span><span class="p">:</span>
<span class="o">-&gt;</span> <span class="n">thread</span> <span class="s2">&quot;A&quot;</span> <span class="n">will</span> <span class="n">run</span> <span class="k">for</span> <span class="mf">3.000</span> <span class="n">sec</span><span class="p">,</span> <span class="n">monitoring</span> <span class="p">[</span><span class="s1">&#39;Py:ao1&#39;</span><span class="p">,</span> <span class="s1">&#39;Py:ai1&#39;</span><span class="p">,</span> <span class="s1">&#39;Py:long1&#39;</span><span class="p">]</span>
<span class="o">-&gt;</span> <span class="n">thread</span> <span class="s2">&quot;B&quot;</span> <span class="n">will</span> <span class="n">run</span> <span class="k">for</span> <span class="mf">6.000</span> <span class="n">sec</span><span class="p">,</span> <span class="n">monitoring</span> <span class="p">[</span><span class="s1">&#39;Py:ai1&#39;</span><span class="p">,</span> <span class="s1">&#39;Py:long1&#39;</span><span class="p">,</span> <span class="s1">&#39;Py:ao2&#39;</span><span class="p">]</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao1</span> <span class="o">=</span> <span class="mf">8.3948</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">3.14</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">3.14</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao1</span> <span class="o">=</span> <span class="mf">0.7404</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">4.07</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">4.07</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">long1</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">long1</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao1</span> <span class="o">=</span> <span class="mf">13.0861</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">8.49</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">8.49</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao2</span> <span class="o">=</span> <span class="mi">30</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="n">Completed</span> <span class="n">Thread</span>  <span class="n">A</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">9.42</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao2</span> <span class="o">=</span> <span class="mi">30</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">long1</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">3.35</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao2</span> <span class="o">=</span> <span class="mi">31</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">4.27</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao2</span> <span class="o">=</span> <span class="mi">31</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">long1</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ai1</span> <span class="o">=</span> <span class="mf">8.20</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
   <span class="n">Py</span><span class="p">:</span><span class="n">ao2</span> <span class="o">=</span> <span class="mi">31</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="n">Completed</span> <span class="n">Thread</span>  <span class="n">B</span>
<span class="n">Done</span>
</pre></div>
</div>
<p>Note that while both threads <em>A</em> and <em>B</em> are running, a callback for the
PV <cite>Py:ai1</cite> is generated in each thread.</p>
<p>Note also that the callbacks for the PVs created in each thread are
<strong>explicitly cleared</strong>  with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">clear_callbacks</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
</pre></div>
</div>
<p>Without this, the callbacks for thread <em>A</em>  will persist even after the
thread has completed!</p>
</section>
</section>
<section id="using-multiprocessing-with-pyepics">
<span id="advanced-multiprocessing-label"></span><span id="index-1"></span><h2>Using Multiprocessing with PyEpics<a class="headerlink" href="#using-multiprocessing-with-pyepics" title="Link to this heading">¶</a></h2>
<p>An alternative to Python threads that has some very interesting and
important features is to use multiple <em>processes</em>, as with the standard
Python <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> module.  While using multiple processes has
some advantages over threads, it also has important implications for use
with PyEpics.  The basic issue is that multiple processes need to be fully
separate, and do not share global state.  For epics Channel Access, this
means that all those things like established communication channels,
callbacks, and Channel Access <strong>context</strong> cannot easily be share between
processes.</p>
<p>The solution is to use a <a class="reference internal" href="#CAProcess" title="CAProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">CAProcess</span></code></a>, which acts just like
<code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.Process</span></code>, but knows how to separate contexts
between processes.  This means that you will have to create PV objects for
each process (even if they point to the same PV).</p>
<dl class="py class">
<dt class="sig sig-object py" id="CAProcess">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CAProcess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CAProcess" title="Link to this definition">¶</a></dt>
<dd><p>a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.Process</span></code> that clears the global
Channel Access context before running you target function in its own
process.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="CAPool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CAPool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">processes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initializer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxtasksperchild</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CAPool" title="Link to this definition">¶</a></dt>
<dd><p>a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.pool.Pool</span></code>, creating a Pool of
<a class="reference internal" href="#CAProcess" title="CAProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">CAProcess</span></code></a> instances.</p>
</dd></dl>

<p>A simple example of using multiprocessing successfully is given:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">epics</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="kn">import</span> <span class="nn">pvnames</span>
<span class="n">PVN1</span> <span class="o">=</span> <span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv</span> <span class="c1"># &#39;Py:ao2&#39;</span>
<span class="n">PVN2</span> <span class="o">=</span> <span class="n">pvnames</span><span class="o">.</span><span class="n">double_pv2</span> <span class="c1"># &#39;Py:ao3&#39;</span>

<span class="k">def</span> <span class="nf">subprocess</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;==subprocess==&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">mypvs</span> <span class="o">=</span> <span class="p">[</span><span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">pvname</span><span class="p">)</span> <span class="k">for</span> <span class="n">pvname</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.750</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">pvname</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">as_string</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">mypvs</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;==sub (</span><span class="si">%d</span><span class="s1">): </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">test_mpprocess</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">monitor</span><span class="p">(</span><span class="n">pvname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">char_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--main:monitor </span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pvname</span><span class="p">,</span> <span class="n">char_value</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--main:&#39;</span><span class="p">)</span>
    <span class="n">pv1</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">get_pv</span><span class="p">(</span><span class="n">PVN1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--main:init </span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">PVN1</span><span class="p">,</span> <span class="n">pv1</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
    <span class="n">pv1</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">callback</span><span class="o">=</span><span class="n">monitor</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">proc1</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">CAProcess</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">subprocess</span><span class="p">,</span>
                                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">PVN1</span><span class="p">,</span> <span class="n">PVN2</span><span class="p">))</span>
        <span class="n">proc1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">proc1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--main: killing subprocess&#39;</span><span class="p">)</span>
        <span class="n">proc1</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--main: subprocess complete&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--main:final </span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">PVN1</span><span class="p">,</span> <span class="n">pv1</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
</pre></div>
</div>
<p>here, the main process and the subprocess can each interact with the same
PV, though they need to create a separate connection (here, using <code class="xref py py-class docutils literal notranslate"><span class="pre">PV</span></code>)
in each process.</p>
<p>Note that different <a class="reference internal" href="#CAProcess" title="CAProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">CAProcess</span></code></a> instances can communicate via
standard <code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.Queue</span></code>.   At this writing,  no testing has
been done on using multiprocessing Managers.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wx.html" title="wx: wxPython Widgets for Epics"
             >previous</a> |</li>
   <li>[<a href="installation.html">install</a></li>
   <li>|<a href="overview.html">overview</a></li>
   <li>|<a href="pv.html">pv</a></li>
   <li>|<a href="ca.html">ca</a></li>
   <li>|<a href="arrays.html">arrays</a></li>
   <li>|<a href="devices.html">devices</a></li>
   <li>|<a href="alarm.html">alarm</a></li>
   <li>|<a href="autosave.html">autosave</a></li>
   <li>|<a href="wx.html">wx</a></li>
   <li>|<a href="#">advanced</a>]</li>

        <li class="nav-item nav-item-this"><a href="">Advanced Topic with Python Channel Access</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021, Matthew Newville.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.6.
    </div>
  </body>
</html>