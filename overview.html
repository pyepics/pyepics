

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Overview of EPICS Channel Access in Python &mdash; Epics Channel Access for Python</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Epics Channel Access for Python" href="index.html" />
    <link rel="next" title="epics.pv the PV object" href="pv.html" />
    <link rel="prev" title="Downloading and Installation" href="installation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pv.html" title="epics.pv the PV object"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Downloading and Installation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Epics Channel Access for Python</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Overview of EPICS Channel Access in Python</a><ul>
<li><a class="reference internal" href="#quick-start">Quick Start</a><ul>
<li><a class="reference internal" href="#functional-approach-caget-caput">Functional Approach: caget(), caput()</a></li>
<li><a class="reference internal" href="#object-oriented-approach-pv">Object Oriented Approach: PV</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-epics">Functions defined in <tt class="docutils literal"><span class="pre">epics</span></tt>: caget(), caput(), etc.</a><ul>
<li><a class="reference internal" href="#caget"><tt class="docutils literal"><span class="pre">caget()</span></tt></a></li>
<li><a class="reference internal" href="#caput"><tt class="docutils literal"><span class="pre">caput()</span></tt></a></li>
<li><a class="reference internal" href="#cainfo"><tt class="docutils literal"><span class="pre">cainfo()</span></tt></a></li>
<li><a class="reference internal" href="#camonitor"><tt class="docutils literal"><span class="pre">camonitor()</span></tt></a></li>
<li><a class="reference internal" href="#camonitor-clear"><tt class="docutils literal"><span class="pre">camonitor_clear()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#motivation-why-another-python-epics-interface">Motivation: Why another Python-Epics Interface?</a></li>
<li><a class="reference internal" href="#status-and-to-do-list">Status and To-Do List</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Downloading and Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pv.html"
                        title="next chapter"><tt class="docutils literal docutils literal"><span class="pre">epics.pv</span></tt>  the PV object</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/overview.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="overview-of-epics-channel-access-in-python">
<h1>Overview of EPICS Channel Access in Python<a class="headerlink" href="#overview-of-epics-channel-access-in-python" title="Permalink to this headline">¶</a></h1>
<p>The epics python package consists of several modules to interact with EPICS
Channel Access.  The simplest approach uses the functions <tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">cainfo()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt>, and
<tt class="xref py py-func docutils literal"><span class="pre">camonitor_clear()</span></tt> within the top-level <cite>epics</cite> module.  These
functions are similar to the Unix command line utilities and to the EZCA
library interface, and described in more detail below.</p>
<p>The <a class="reference internal" href="#module-epics" title="epics: top-level epics module, and container for simplest CA functions"><tt class="xref py py-mod docutils literal"><span class="pre">epics</span></tt></a> package consists of several functions, modules and classes
that are imported with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">epics</span>
</pre></div>
</div>
<p>These components includes</p>
<blockquote>
<div><ul class="simple">
<li>functions <tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">camonitor_clear()</span></tt>, and <tt class="xref py py-func docutils literal"><span class="pre">cainfo()</span></tt> as described below.</li>
<li>a <a class="reference internal" href="ca.html#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module, providing the low-level Epics Channel Access
library as a set of functions.</li>
<li>a <tt class="xref py py-class docutils literal"><span class="pre">PV</span></tt> object, giving a higher-level interface to Epics
Channel Access.</li>
<li>a <tt class="xref py py-class docutils literal"><span class="pre">Device</span></tt> object:  a collection of related PVs</li>
<li>a <tt class="xref py py-class docutils literal"><span class="pre">Motor</span></tt> object: a mapping of an Epics Motor</li>
<li>an <tt class="xref py py-class docutils literal"><span class="pre">Alarm</span></tt> object, which can be used to set up notifications
when a PV's values goes outside an acceptable bounds.</li>
<li>an <tt class="xref py py-mod docutils literal"><span class="pre">epics.wx</span></tt> module that provides wxPython classes designed for
use with Epics PVs.</li>
</ul>
</div></blockquote>
<p>If you're looking to write quick scripts, using the <tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt> and
<tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt>  functions is probably how you want to start.</p>
<p>Users looking to build larger-scale solutions recommended to use
<tt class="xref py py-class docutils literal"><span class="pre">PV</span></tt> objects provided by the <a class="reference internal" href="pv.html#module-pv" title="pv: PV objects for Epics Channel Access"><tt class="xref py py-mod docutils literal"><span class="pre">pv</span></tt></a> module.  The <tt class="xref py py-class docutils literal"><span class="pre">PV</span></tt>
class provides a Process Variable object that has both methods (including
<tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt>) to read and change the PV, and attributes that
are kept automatically synchronized with the remote channel.</p>
<p>The lowest-level CA functionality is exposed in the <a class="reference internal" href="ca.html#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> and
<tt class="xref py py-mod docutils literal"><span class="pre">dbr</span></tt> module.  While not necessary for most use, this module does
provide a fairly complete wrapping of the basic EPICS CA library.  For
people who have used CA from C or other languages, this module should be
familiar and quite usable, if a little more verbose and C-like than using
PV objects.</p>
<p>In addition, the <cite>epics</cite> package contains more specialized modules for
Epics motors, alarms, a host of other <em>devices</em> (collections of PVs), and a
set of wxPython widget classes for using EPICS PVs with wxPython.</p>
<p>The <cite>epics</cite> package is targeted for use on Unix-like systems (including
Linux and Mac OS X) and Windows with Python versions 2.5, 2.6, and 3.1.</p>
<div class="section" id="quick-start">
<h2>Quick Start<a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h2>
<p>If you're somewhat familiar with Epics Channel Access, you may be able to
get started right away without reading the full documentation, and then use
Python's introspection tools and  built-in help system, referring to this
documentation for further details.</p>
<div class="section" id="functional-approach-caget-caput">
<h3>Functional Approach: caget(), caput()<a class="headerlink" href="#functional-approach-caget-caput" title="Permalink to this headline">¶</a></h3>
<p>To get values from PVs, you can simply use the <tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">caget</span><span class="p">,</span> <span class="n">caput</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">m1</span>
<span class="go">1.2001</span>
</pre></div>
</div>
<p>To set PV values, you can simply use the <tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">caput</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">,</span> <span class="mf">1.90</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">)</span>
<span class="go">1.9000</span>
</pre></div>
</div>
<p>For many uses, the simplicity and clarity of this approach is perfect.</p>
</div>
<div class="section" id="object-oriented-approach-pv">
<h3>Object Oriented Approach: PV<a class="headerlink" href="#object-oriented-approach-pv" title="Permalink to this headline">¶</a></h3>
<p>If you want to repeatedly access the same PV, you may find it more
convenient to ''create a PV object'' and use it in a more object-oriented
manner.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">PV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pv1</span> <span class="o">=</span> <span class="n">PV</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>PV objects have several methods and attributes.  The most important methods
are  <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt> to receive and send the PV's value, and
the <tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> attribute which stores the current value.  In analogy to
the <tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt> examples above, the value of a PV can
be fetched either with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pv1</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">1.2001</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pv1</span><span class="o">.</span><span class="n">value</span>
<span class="go">1.2001</span>
</pre></div>
</div>
<p>To set a PV's value, you can either use</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pv1</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mf">1.9</span><span class="p">)</span>
</pre></div>
</div>
<p>or assign the <tt class="xref py py-attr docutils literal"><span class="pre">value</span></tt> attribute</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pv1</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">1.9</span>
</pre></div>
</div>
<p>PV objects have several more methods, especially related to monitoring
external changes to the PVs and defining functions to be run automatically
when the value changes.  There are also several attributes associated with
a PV reflecting the <tt class="docutils literal"><span class="pre">Control</span> <span class="pre">Attributes</span></tt>.  Further details are at
<a class="reference internal" href="pv.html#pv-label"><em>epics.pv  the PV object</em></a></p>
</div>
</div>
<div class="section" id="module-epics">
<span id="functions-defined-in-epics-caget-caput-etc"></span><h2>Functions defined in <a class="reference internal" href="#module-epics" title="epics: top-level epics module, and container for simplest CA functions"><tt class="xref py py-mod docutils literal"><span class="pre">epics</span></tt></a>: caget(), caput(), etc.<a class="headerlink" href="#module-epics" title="Permalink to this headline">¶</a></h2>
<p>The simplest interface to EPICS Channel Access provides functions
<a class="reference internal" href="#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt></a>, <a class="reference internal" href="#epics.caput" title="epics.caput"><tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt></a>, as well as functions <a class="reference internal" href="#epics.camonitor" title="epics.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt></a>,
<a class="reference internal" href="#epics.camonitor_clear" title="epics.camonitor_clear"><tt class="xref py py-func docutils literal"><span class="pre">camonitor_clear()</span></tt></a>, and <a class="reference internal" href="#epics.cainfo" title="epics.cainfo"><tt class="xref py py-func docutils literal"><span class="pre">cainfo()</span></tt></a>.  These are similar to the
EPICS command line utilities and to the functions in the EZCA library, in
that these function all take the name of an Epics Process Variable (PV) as
the first argument.  As with the EZCA library, the python implementation
actually keeps a cache of already connected PV (in this case, using
internally monitored <cite>PV</cite> objects) so that repeated use of a PV name does
not actually result in a new connection to that PV.  Thus, though the
functionality is limited, the performance of the functional approach can be
quite good.</p>
<div class="section" id="caget">
<h3><a class="reference internal" href="#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">caget()</span></tt></a><a class="headerlink" href="#caget" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="epics.caget">
<tt class="descclassname">epics.</tt><tt class="descname">caget</tt><big>(</big><em>pvname[, as_string=False[, count=None[, as_numpy=True]</em><big>)</big><a class="headerlink" href="#epics.caget" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieves and returns the value of the named PV.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pvname</strong> -- name of Epics Process Variable</li>
<li><strong>as_string</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to return string representation of the PV value.</li>
<li><strong>count</strong> -- number of elements to return for array data.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The <em>count</em> and <em>as_numpy</em> options apply only to array or waveform
data. The default behavior is to return the full data array and convert to
a numpy array if available.</p>
<p>The <em>as_string</em> argument tells the function to return the <strong>string
representation</strong> of the value.  The details of the string representation
depends on the variable type of the PV.  For integer (short or long) and
string PVs, the string representation is pretty easy: 0 will become '0',
for example..  For float and doubles, the internal precision of the PV is
used to format the string value.  For enum types, the name of the enum
state is returned:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">caget</span><span class="p">,</span> <span class="n">caput</span><span class="p">,</span> <span class="n">cainfo</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">)</span>     <span class="c"># A double PV</span>
<span class="go">0.10000000000000001</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.DESC&#39;</span><span class="p">)</span>    <span class="c"># A string PV</span>
<span class="go">&#39;Motor 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.FOFF&#39;</span><span class="p">)</span>    <span class="c"># An Enum PV</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Adding the <cite>as_string=True</cite> argument always results in string being
returned, with the conversion method depending on the data type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">,</span> <span class="n">as_string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;0.10000&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:m1.FOFF&#39;</span><span class="p">,</span> <span class="n">as_string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;Frozen&#39;</span>
</pre></div>
</div>
<p>For most array data from Epics waveform records, the regular value will be
a numpy array (or a python list if numpy is not installed).  The string
representation will be something like '&lt;array size=128, type=int&gt;'
depending on the size and type of the waveform.  An array of doubles might
be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:scan1.P1PA&#39;</span><span class="p">)</span>  <span class="c"># A Double Waveform</span>
<span class="go">array([-0.08      , -0.078     , -0.076     , ...,</span>
<span class="go">    1.99599814, 1.99799919,  2.     ])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:scan1.P1PA&#39;</span><span class="p">,</span> <span class="n">as_string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;&lt;array size=2000, type=DOUBLE&gt;&#39;</span>
</pre></div>
</div>
<p>As an important special case, CHAR waveforms will be turned to Python
strings when <em>as_string</em> is <tt class="xref docutils literal"><span class="pre">True</span></tt>.  This is to work around the low limit
of the maximum length (40 characters!) of EPICS strings, and means that it
is fairly common to use CHAR waveforms when long strings are desired:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:dir&#39;</span><span class="p">)</span>      <span class="c"># A CHAR waveform</span>
<span class="go">array([ 84,  58,  92, 120,  97, 115,  95, 117, 115,</span>
<span class="go">   101, 114,  92,  77,  97, 114,  99, 104,  50,  48,</span>
<span class="go">    49,  48,  92,  70,  97, 115, 116,  77,  97, 112,</span>
<span class="go">     0,   0, ... 0])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">caget</span><span class="p">(</span><span class="s">&#39;XXX:dir&#39;</span><span class="p">,</span><span class="n">as_string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;T:\\xas_user\\March2010\\FastMap&#39;</span>
</pre></div>
</div>
<p>Of course, some character waveforms are not used for long strings but to
hold byte array data.</p>
</div>
<div class="section" id="caput">
<h3><a class="reference internal" href="#epics.caput" title="epics.caput"><tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt></a><a class="headerlink" href="#caput" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="epics.caput">
<tt class="descclassname">epics.</tt><tt class="descname">caput</tt><big>(</big><em>pvname</em>, <em>value</em><span class="optional">[</span>, <em>wait=False</em><span class="optional">[</span>, <em>timeout=60</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#epics.caput" title="Permalink to this definition">¶</a></dt>
<dd><p>set the value of the named PV.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pvname</strong> -- name of Epics Process Variable</li>
<li><strong>value</strong> -- value to send.</li>
<li><strong>wait</strong> (<em>True or False</em>) -- whether to wait until the processing has completed.</li>
<li><strong>timeout</strong> (<em>double</em>) -- how long to wait (in seconds) for put to complete before giving up.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">integer</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The optional <em>wait</em> argument tells the function to wait until the
processing completes.  This can be useful for PVs which take significant
time to complete, either because it causes a physical device (motor, valve,
etc) to move or because it triggers a complex calculation or data
processing sequence.  The <em>timeout</em> argument gives the maximum time to
wait, in seconds.  The function will return after this (approximate) time
even if the <a class="reference internal" href="#epics.caput" title="epics.caput"><tt class="xref py py-func docutils literal"><span class="pre">caput()</span></tt></a> has not completed.</p>
<p>This function returns 1 on success, and a negative number if the timeout
has been exceeded.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">caget</span><span class="p">,</span> <span class="n">caput</span><span class="p">,</span> <span class="n">cainfo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caput</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">,</span><span class="mf">2.30</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">caput</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">,</span><span class="o">-</span><span class="mf">2.30</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">... </span><span class="n">waits</span> <span class="n">a</span> <span class="n">few</span> <span class="n">seconds</span> <span class="o">...</span>
<span class="go">1</span>
</pre></div>
</div>
</div>
<div class="section" id="cainfo">
<h3><a class="reference internal" href="#epics.cainfo" title="epics.cainfo"><tt class="xref py py-func docutils literal"><span class="pre">cainfo()</span></tt></a><a class="headerlink" href="#cainfo" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="epics.cainfo">
<tt class="descclassname">epics.</tt><tt class="descname">cainfo</tt><big>(</big><em>pvname</em><span class="optional">[</span>, <em>print_out=True</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#epics.cainfo" title="Permalink to this definition">¶</a></dt>
<dd><p>prints (or returns as a string) an informational paragraph about the PV,
including Control Settings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pvname</strong> -- name of Epics Process Variable</li>
<li><strong>print_out</strong> -- whether to write results to standard output
(otherwise the string is returned).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="camonitor">
<h3><a class="reference internal" href="#epics.camonitor" title="epics.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt></a><a class="headerlink" href="#camonitor" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="epics.camonitor">
<tt class="descclassname">epics.</tt><tt class="descname">camonitor</tt><big>(</big><em>pvname</em><span class="optional">[</span>, <em>writer=None</em><span class="optional">[</span>, <em>callback=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#epics.camonitor" title="Permalink to this definition">¶</a></dt>
<dd><p>This <cite>sets a monitor</cite> on the named PV, which will cause <em>something</em> to be
done each time the value changes.  By default the PV name, time, and
value will be printed out (to standard output) when the value changes,
but the action that actually happens can be customized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pvname</strong> -- name of Epics Process Variable</li>
<li><strong>writer</strong> (<em>None or a method that takes a string argument.</em>) -- where to write results to standard output .</li>
<li><strong>callback</strong> (<em>None or callable function</em>) -- user-supplied function to receive result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>One can specify any function that can take a string as <em>writer</em>, such as
the <cite>write</cite> method of a file that has been open for writing.  If left as
<tt class="xref docutils literal"><span class="pre">None</span></tt>, messages of changes will be sent to <tt class="xref py py-func docutils literal"><span class="pre">sys.stdout.write()</span></tt>. For
more complete control, one can specify a <em>callback</em> function to be called
on each change event.  This callback should take keyword arguments for
<em>pvname</em>, <em>value</em>, and <em>char_value</em>.  See <a class="reference internal" href="pv.html#pv-callbacks-label"><em>User-supplied Callback functions</em></a> for
information on writing callback functions for <a class="reference internal" href="#epics.camonitor" title="epics.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">camonitor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camonitor</span><span class="p">(</span><span class="s">&#39;XXX.m1.VAL&#39;</span><span class="p">)</span>
<span class="go">XXX.m1.VAL 2010-08-01 10:34:15.822452 1.3</span>
<span class="go">XXX.m1.VAL 2010-08-01 10:34:16.823233 1.2</span>
<span class="go">XXX.m1.VAL 2010-08-01 10:34:17.823233 1.1</span>
<span class="go">XXX.m1.VAL 2010-08-01 10:34:18.823233 1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="camonitor-clear">
<h3><a class="reference internal" href="#epics.camonitor_clear" title="epics.camonitor_clear"><tt class="xref py py-func docutils literal"><span class="pre">camonitor_clear()</span></tt></a><a class="headerlink" href="#camonitor-clear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="epics.camonitor_clear">
<tt class="descclassname">epics.</tt><tt class="descname">camonitor_clear</tt><big>(</big><em>pvname</em><big>)</big><a class="headerlink" href="#epics.camonitor_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clears a monitor set on the named PV by <a class="reference internal" href="#epics.camonitor" title="epics.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pvname</strong> -- name of Epics Process Variable</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This simple example monitors a PV with <a class="reference internal" href="#epics.camonitor" title="epics.camonitor"><tt class="xref py py-func docutils literal"><span class="pre">camonitor()</span></tt></a> for while, with
changes being saved to a log file.   After a while, the monitor is cleared
and the log file is inspected:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">epics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;PV1.log&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epics</span><span class="o">.</span><span class="n">camonitor</span><span class="p">(</span><span class="s">&#39;XXX:DMM1Ch2_calc.VAL&#39;</span><span class="p">,</span><span class="n">writer</span><span class="o">=</span><span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">....</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">changes</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epics</span><span class="o">.</span><span class="n">camonitor_clear</span><span class="p">(</span><span class="s">&#39;XXX:DMM1Ch2_calc.VAL&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;PV1.log&#39;</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fh</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span> <span class="k">print</span> <span class="n">i</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:40.536946 -183.5035</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:41.536757 -183.6716</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:42.535568 -183.5112</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:43.535379 -183.5466</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:44.535191 -183.4890</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:45.535001 -183.5066</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:46.535813 -183.5085</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:47.536623 -183.5223</span>
<span class="go"> XXX:DMM1Ch2_calc.VAL 2010-03-24 11:56:48.536434 -183.6832</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="motivation-why-another-python-epics-interface">
<h2>Motivation: Why another Python-Epics Interface?<a class="headerlink" href="#motivation-why-another-python-epics-interface" title="Permalink to this headline">¶</a></h2>
<p>Py-Epics3 is intended as an improvement over EpicsCA 2.1, and should
replace that older Epics-Python interface.  That version had performance
issues, especially when connecting to a large number of PVs, is not
thread-aware, and has become difficult to maintain for Windows and Linux.</p>
<p>There are a few other Python modules exposing Epics Channel Access
available.  Most of these have a interface to the CA library that was both
closer to the C library and lower-level than EpicsCA.  Most of these
interfaces use specialized C-Python 'wrapper' code to provide the
interface.</p>
<p>Because of this, an additional motivation for this package was to allow a
more common interface to be used that built higher-level objects (as
EpicsCA had) on top of a complete lower-level interface.  The desire to
come to a more universally-acceptable Python-Epics interface has definitely
influenced the goals for this module, which include:</p>
<blockquote>
<div><ol class="arabic simple">
<li>providing both low-level (C-like) and higher-level access (Pythonic
objects) to the EPICS Channel Access protocol.</li>
<li>supporting as many features of Epics 3.14 as possible, including
preemptive callbacks and thread support.</li>
<li>easy support and distribution for Windows and Unix-like systems.</li>
<li>being ready for porting to Python3.</li>
<li>using Python's ctypes library.</li>
</ol>
</div></blockquote>
<p>The main implementation feature used here (and difference from EpicsCA) is
using Python's ctypes library to handle the connection between Python and
the CA C library.  Using ctypes has many advantages.  Principally, it fully
eliminates the need to write (and maintain) wrapper code either with SWIG
or directly with Python's C API.  Since the ctypes module allows access to
C data and objects in pure Python, no compilation step is needed to build
the module, making installation and support on multiple platforms much
easier.  Since ctypes loads a shared object library at runtime, the
underlying Epics Channel Access library can be upgraded without having to
re-build the Python wrapper.  In addition, using ctypes provides the most
reliable thread-safety available, as each call to the underlying C library
is automatically made thread-aware without explicit code.  Finally, by
avoiding the C API altogether, migration to Python3 is greatly simplified.
PyEpics3 does work with both Python 2.* and 3.*.</p>
</div>
<div class="section" id="status-and-to-do-list">
<h2>Status and To-Do List<a class="headerlink" href="#status-and-to-do-list" title="Permalink to this headline">¶</a></h2>
<p>The Epics3 package is under active development.   The current status is that
most features are working well, and it is starting to be used in production
code, but more testing and better tests are needed.</p>
<p>The package is targeted and tested to work with Python 2.5, 2.6, 2.7, and
3.1 simultaneously (that is, the same code is meant to support all
versions).  Currently, the package works with Python 3.1, but is not
extremely well-tested.</p>
<p>There are several desired features are left undone or unfinished:</p>
<blockquote>
<div><ul>
<li><p class="first">port CaChannel interface, ca_util, epicsPV (and other interfaces??) to use epics.ca</p>
</li>
<li><p class="first">add more &quot;devices&quot;, including low-level epics records.</p>
</li>
<li><p class="first">further testing for Python 3.1</p>
</li>
<li><p class="first">further testing for threading and 'contexts'.</p>
</li>
<li><p class="first">include dedicate epics db records to facilitate better automated testing.</p>
</li>
<li><p class="first">build and distribute example Epics applications, such as:</p>
<blockquote>
<div><ul class="simple">
<li>PV stripcharter</li>
<li>Probe replacement</li>
<li>application to manage saved &quot;positions&quot; of multiple PVs in an
&quot;instrument&quot;.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pv.html" title="epics.pv the PV object"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Downloading and Installation"
             >previous</a> |</li>
        <li><a href="index.html">Epics Channel Access for Python</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Matthew Newville.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>